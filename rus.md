# Игра с дополненной реальностью: технический обзор

[«An AR Game»][1] — победитель в конкурсе приложений [Dev Derby][3], который прошел  в [марте 2013 года][2]. Данное приложение представляет из себя небольшую игру, опирающуюся на технологию [дополненной реальности][4] *(augmented reality, далее AR, прим. ред.)*, цель которой состоит в перемещении катящихся игровых элементов из мира с двухмерной физикой в трёхмерное пространство. Демо игры [доступно на GitHub][5], или же вы можете [посмотреть её презентацию на YouTube][6]. 
В рамках этой статьи мы постараемся описать дизайнерские и инженерные решения, которые легли в основу игры.

Технически, игра базируется на простом и одновременно изысканном соединении четырех технологий с открытым исходным кодом: [WebRTC][7], [JSARToolkit][8], [ThreeJS][9] и [Box2D.js][10]. 
Мы постарались дать краткое описание каждой из них и объяснить их взаимосвязь в проекте. 
Начиная с нуля, мы с вами постепенно будем создавать данную игру.
Код, рассмотренный в этой статье, размещён на [github][11], на каждом этапе этого урока представлены ссылки на соответствующий [исходник примера из проекта][12] и его [демо][13]-страницу. Некоторые обобщённые отрывки исходного кода будут представлены в самой статье, полный процесс создания кода вы сможете отследить по ссылкам на «диффы» примеров из проекта. Также, по возможности, мы постараемся продемонстрировать поведение приложения на том или ином этапе через видео-ролики.

> git clone https://github.com/abrie/devderby-may-2013-technical.git

По ходу урока мы сначала рассмотрим AR-плоскость ([реальное пространство][14]), затем 2D-плоскость ([плоское пространство][15]) и в завершении, их [взаимодействие][16].

## Плоскость реального пространства

Реальное пространство, в данном контексте — это то пространство, которое видит камера, дополненное виртуальными объектами. 

### Начнём с каркаса приложения

> git checkout example_0

> [демо][17], [дифф][18], [исходник примера][19]

Для начала, разобьем весь код на модули, используя [RequireJS][20]. 
Нашей отправной точкой будет служить главный модуль с двумя каркасными методами, часто используемыми в играх. Это `initialize()`, вызывающий запуск и `tick()` для рендеринга каждого фрейма. 
Обратите внимание, что игровой цикл приводится в действие посредством 
повторяющихся обращений к [`requestAnimationFrame`][21]:

    requirejs([], function() {
 
        // Инициализация компонентов и начало игрового цикла 
        function initialize() {
        }
 
        // Выполнение одной итерации игрового цикла 
        function tick() {
            // Запрос следующей итерации игрового цикла 
            window.requestAnimationFrame(tick);
        }
 
        // Запуск приложения 
        initialize();
        tick();
    });

На данном этапе у нас есть приложение с пустым циклом. Продолжим разработку, 
используя созданный нами каркас. 

### Наделяем каркас зрением

> git checkout example_1

> [демо][22], [дифф][23], [исходник примера][24]

Для нашей игры с AR нам необходима потоковая видеотрансляция в реальном времени. [WebRTC][26] на основе [HTML5][25] предоставляет возможность организации такой трансляции, обеспечивая доступ к [вебкамере][27] игрока.
Из чего, кстати, следует, что наш проект с AR будет работать только в современных браузерах, вроде [Firefox][28]. 
Подробную документация по WebRTC и [getUserMedia][29] вы легко можете найти самостоятельно на [developer.mozilla.org][30], так что мы не будем дублировать ее тут.

Библиотека для камеры представляет собой модуль для [RequireJS][31] под названием [webcam.js][32], который мы встроим в наш каркас.

Первоначально, камеру инициализировать и авторизировать в приложении. [После получения согласия пользователя модуль webcam.js запускает callback-функцию][33], затем после каждого запроса `tick()` в игровом цикле [фрейм копируется из элемента `video` в `context` для `canvas`][34]. Это важно, потому что таким образом мы можем взаимодействовать с видеоданными. Мы будем использовать этот принцип в последующих разделах, а пока наше приложение представляет собой просто `canvas`, внутри которого обновляется видео-фрейм после каждого запроса `tick()`.

### Имитация зрительной зоны коры головного мозга

> git checkout example_2

> [демо][35], [дифф][36], [исходник примера][37]

Представляем вашему вниманию JSARToolkit — движок для дополненной реальности. Он определяет и описывает положение [координатных маркеров][37] в специальных изображениях. Каждый маркер привязан к уникальному номеру (ID) в движке. Изображения с маркерами, которые распознаются библиотекой JSARToolkit, представлены [здесь][39], в формате PNG. Имена файлов обозначают ID маркера в библиотеке. На момент написания данной статьи Github не поддерживал расширение PNG, и все маркеры имеют расширения txt. Если вы собираетесь их использовать, вам придется их переименовать обратно в PNG после скачивания.

Для этой игры мы будем использовать маркеры №16 и №32, объединённые на одной 
карточке: 

![Маркеры №16 и №32, объединённые на одной карточке][маркеры]

JSARToolkit походит от [ARToolkit][40], который был написан в [C++][41] в 
лаборатории [HITLab][43] [Вашингтонского университета][42] в [Сиэтле][44]. Оригинал бы скопирован и портирован на ряд других языков, в том числе [Java][45], затем с Java на [Flash][46], и, наконец, с Flash на [JS][47]. 
Столь тернистый путь наложил свой отпечаток на использование библиотеки. В частности, вы наверняка отметите далее, что некоторые названия непоследовательны и слегка нестандартны. 

Давайте взглянем на чистый функционал:

    // Объект raster — это canvas, в который мы копируем видео-фреймы.
     var JSARRaster = NyARRgbRaster_Canvas2D(canvas);
 
     // Объект parameters обозначает размеры входящей видеотрансляции в пикселях.
     var JSARParameters = new FLARParam(canvas.width, canvas.height);
 
     // MultiMarkerDetector — движок для распознавания маркера
     var JSARDetector = new FLARMultiIdMarkerDetector(FLARParameters, 120);
     JSARDetector.setContinueMode(true);
 
     // Запуск детектора для фрейма, который возвращает количество распознанных маркеров.
     var threshold = 64;
     var count = JSARDetector.detectMarkerLite(JSARRaster, threshold);

После обработки фрейма `JSARDetector.detectMarkerLite()`, объект `JSARDetector` будет содержать список распознанных маркеров. `JSARDetector.getIdMarkerData(index)` возвращает номер ID, а `JSARDetector.getTransformMatrix(index)` возвращает положение в пространстве. 
Пользоваться этими методами слегка неудобно, поэтому мы [обернём 
их в][48] [вспомогательные методы][49] и вызовем из цикла таким способом:

    var markerCount = JSARDetector.detectMarkerLite(JSARRaster, 90); 
 
    for( var index = 0; index < markerCount; index++ ) {
        // Получение уникального номера распознанного маркера.
        var id = getMarkerNumber(index);
 
        // Получение матрицы перехода для распознанного маркера.
        var matrix = getTransformMatrix(index);
    }

Поскольку детектор оперирует каждым фреймом в отдельности, ответственность за состояние маркера в промежутках между фреймами ложится на нас. 
Например, между двумя последовательными фреймами может случиться что-нибудь из нижеследующего:

* может быть распознан новый маркер;
* существующий маркер может изменить расположение;
* существующий маркер может исчезнуть из потока.

Отслеживание состояния [реализуется с помощью ardetector.js][50]. 
Для этого мы создаем копию `canvas`, в который передаются фреймы из видео:

    // Создаем детектор маркера AR, используя canvas в качестве источника данных
    var detector = ardetector.create( canvas );

С каждым запросом `tick()` [изображение в `canvas` сканируется детектором][51] и [при необходимости запускается callback-функция][52]:

    // Распоряжение для детектора выполнить распознание. 
    detector.detect( onMarkerCreated, onMarkerUpdated, onMarkerDestroyed );

Как видно по коду, теперь наше приложение [распознаёт маркеры][53] и [выводит 
результаты распознавания в консоль][54].

### Реальность как плоскость

> git checkout example_3

> [демо][55], [дифф][56], [исходник примера][57]

Как мы писали выше, изображение с дополненной реальностью состоит из *реального* изображения с наложенными поверх него 3D-моделями. 
Исходя из этого можно понять, что воспроизведение AR-изображения обычно 
делится на два этапа. Первый этап — воспроизведение *реального* изображения, 
захваченного камерой. В предыдущих примерах [мы просто скопировали это 
изображение в `canvas`][58]. Теперь нам необходимо дополнить наше изображение 3D-моделями, а для этого нам нужен [WebGL][59] canvas. Задача усложнена тем, что в WebGL canvas нет подходящего нам метода `context`, в который мы могли бы скопировать изображение. Вместо того мы будем передавать в WebGL рендер [текстурированную плоскость][60], используя изображения с вебкамеры в качестве текстуры. ThreeJS может воспринимать наш `canvas` как источник с текстурой, так что [мы можем вводить в него `canvas`][61], [в который передаются фреймы из видео][62]:

    // Создаём текстуру texture, связанную с canvas.
    var texture = new THREE.Texture(canvas);

ThreeJS кэширует текстуры, следовательно, каждый раз когда фрейм копируется 
в `canvas`, должен быть установлен флаг, обновляющий текстуру в кэше: 

    // Когда текстура изменилась, нам нужно сообщить об этом ThreeJS 
    function update() {
        texture.needsUpdate = true;
    }

![Страница с маркерами почти готова к тому чтобы быть дополненной][Страница с маркерами]

В качестве результата у нас есть приложение, которое, с точки зрения пользователя, ничем не отличается от [примера №2][64]. Однако, за кадром сплошной WebGL. Следующий шаг — «дополнить» его!

### Дополняем реальность

> git checkout example_4

> [демо][65], [дифф][66], [исходник примера][67], [видео][68]

Мы готовы добавить в наш коктейль «дополнительные» ингредиенты: они должны будут принимать форму 3D-моделей, зафиксированных по маркерам, которые сняла наша камера. Для начала, нам нужно разрешить обмен данными между детектором `ardetector` и ThreeJS, это даст нам возможность построить модели, которыми можно дополнить координатные метки.

#### Шаг 1. Трансформационный перевод

Программисты, знакомые с 3D-графикой, знают, что для рендеринга необходимы две матрицы: модельная матрица ([матрица трансформации][69]) и матрица камеры ([проекционная матрица][70]). Матрицы можно получить, используя [ardetector][71], встроенный нами в код ранее, но, их нельзя использовать «как есть», без изменений — массивы матриц, полученные ardetector, несовместимы с ThreeJS напрямую. Например, вспомогательный метод 
`getTransformMatrix()` возвращает массив [Float32Array][72], который ThreeJS не понимает. К счастью, их можно легко конвертировать напрямую через расширение прототипа методом [«monkey patching» (обезьяний патчинг)][73]:

    // Разрешаем установку Matrix4 с помощью Float32Array
    THREE.Matrix4.prototype.setFromArray = function(m) {
     return this.set(
      m[0], m[4], m[8],  m[12],
      m[1], m[5], m[9],  m[13],
      m[2], m[6], m[10], m[14],
      m[3], m[7], m[11], m[15]
     );
    }

Эта манипуляция позволяет нам настроить матрицу трансформации в нужный формат, но на практике мы увидим, что обновление не приносит никакого эффекта. Причина этому — механизм [кэширования][74] в ThreeJS. Чтобы привести в действие изменения, мы создадим объект-контейнер и [установим в значении `false` флаг `matrixAutoUpdate`][75]. Затем, при каждом обновлении в матрице, [устанавливаем для `matrixWorldNeedsUpdate` значение `true`][76].

#### Шаг 2. Куб, отмечающий маркер

Теперь, используем наши обезьяньи патчи и объекты-контейнеры, чтобы отобразить 
разноцветные кубики в качестве маркеров AR. Сначала создадим сетку куба, с 
размерами, достаточными для заполнения координатной метки: 

    function createMarkerMesh(color) {
        var geometry = new THREE.CubeGeometry( 100,100,100 );
        var material = new THREE.MeshPhongMaterial( {color:color, side:THREE.DoubleSide } );
 
        var mesh = new THREE.Mesh( geometry, material );                      
 
        //Отрицательное значение, равное половине высоты объекта, располагает объект над маркером AR.
        mesh.position.z = -50; 
 
        return mesh;
    }

Затем поместим сетку в [объект-контейнер][77]: 

    function createMarkerObject(params) {
        var modelContainer = createContainer();
 
        var modelMesh = createMarkerMesh(params.color);
        modelContainer.add( modelMesh );
 
        function transform(matrix) {
            modelContainer.transformFromArray( matrix );
        }
    }

Далее, генерируем маркер-объекты, с привязкой к номеру ID карточки маркера:

    // Создаём маркер-объекты, соответствующие желаемому номеру ID маркера.
        var markerObjects = {
            16: arobject.createMarkerObject({color:0xAA0000}), // Маркер #16, красный.
            32: arobject.createMarkerObject({color:0x00BB00}), // Маркер #32, зелёный.
        };

Callback-функции `ardetector.detect()` [применяют матрицу трансформации 
к соответствующему маркеру][78]. Например, здесь обработчик `onCreate` добавляет трансформированную модель в AR-отображение:

    // Эта функция вызывается, когда маркер впервые распознаётся в потоке
    function onMarkerCreated(marker) {
        var object = markerObjects[marker.id];
 
        // Установка исходной матрицы трансформации для объекта.
        object.transform( marker.matrix );
 
        // Добавление объекта к сцене.
        view.add( object );
    }
    });

![Теперь наше приложение представляет собой функционирующий пример дополненной реальности][кубики]

Теперь наше приложение представляет собой функционирующий пример дополненной 
реальности!

### Создаём отверстия

В игре «An AR Game» маркеры — это не просто разноцветные кубики. Они являются 
своего рода туннелями, которые визуально вогнуты внутрь карточки с маркерами. 
Чтобы воспроизвести такой эффект, нам придётся немного схитрить, для 
наглядности мы воплотим его в три шага. 

#### Шаг 1: Открытие куба

> git checkout example_5

> [демо][79], [дифф][80], [исходник примера][81], [видео][82]

Сначала создадим открытую коробку, удалив верхнюю стенку куба. Для этого 
[сделаем материал стенки][83] [невидимым][84]. Открытая коробка расположена 
*позади, и одновременно, под* карточкой с маркером [благодаря тому, что координаты по оси Z равны половине высоты коробки][85].

![Эффект интересный, незаконченный — и, вероятно, не сразу понятно в чём дело.][незаконченный эффект]

Эффект интересный, незаконченный — и, вероятно, не сразу понятно в чём дело.

#### Шаг 2. Покрываем куб синим цветом

> git checkout example_6

> [демо][86], [дифф][87], [исходник примера][88], [видео][89]

Итак, что мы пропустили? Нам нужно спрятать ту часть кубика, которая должна быть *сзади* листа с маркером. Этого можно достичь, для начала, заключив кубик в [куб побольше][90]. Назовем этот куб «блокатором», в [шаге №3][91] он будет играть роль плаща-невидимки. Пока оставим его [видимым и закрасим синим цветом][92] для наглядности. 

[Объекты-блокаторы][93] и [объекты дополненной реальности][94] воспроизводятся в одном контексте, но отдельных сценах: 

    function render() {
        // Отрисовка реальной сцены 
        renderer.render(reality.scene, reality.camera);
 
        // Отрисовка сцены с блокатором 
        renderer.render( occluder.scene, occluder.camera);
 
        // Отрисовка компонентов дополненной реальности поверх реальной сцены.
        renderer.render(virtual.scene, virtual.camera);
    }

![Прячем ту часть коробки, которая должна быть сзади листа с маркером][синий]

Синяя обёртка пока не способствует созданию иллюзии туннеля. 

#### Шаг 3: Части куба становятся невидимыми

> git checkout example_7

> [демо][96], [дифф][97], [исходник примера][98], [видео][99]

Для окончательного создания иллюзии нужно, чтобы синяя «накидка» стала невидимой, сохраняя свои возможности блокатора — она должна стать невидимым блокатором. Фокус в том, чтобы отключить цветовые буфера и производить отрисовку только в буфере глубины. 
[Используем метод `render()`][101]:

    function render() {
        // Отрисовка реальной сцены
        renderer.render(reality.scene, reality.camera);
 
        // Отключение цветового и альфа- буферов, оставляем включённым только буфер глубины.
        renderer.context.colorMask(false,false,false,false);
 
        // Отрисовка сцены с блокатором
        renderer.render( occluder.scene, occluder.camera);
 
        // Включение цветового и альфа- буферов.
        renderer.context.colorMask(true,true,true,true);
 
        // Отрисовка компонентов дополненной реальности поверх реальной сцены.
        renderer.render(virtual.scene, virtual.camera);
    }

![Иллюзия][Иллюзия]

Этот результат уже более похож на нужную нам иллюзию.

### Выбираем отверстия

> git checkout example_8

> [демо][102], [дифф][103], [исходник примера][104]

В игре «An AR Game» пользователь может выбрать, какой туннель открыть, разместив маркер под прицельную сетку. Это ключевой аспект игры, с технической точки зрения его можно назвать *выбором объекта*. Благодаря ThreeJS это довольно просто реализовать. Ключевые классы — `THREE.Projector()` и `THREE.Raycaster()`, однако есть небольшая оговорка: хотя ключевой метод имеет название `Raycaster.intersectObject()`, он принимает `THREE.Mesh` в качестве параметра. Следовательно, мы [добавляем сетку с названием «хитбокс»][106] в 
`createMarkerObject()`. В нашем случае — [это невидимая геометрическая плоскость][107]. Обратите внимание, что мы не указываем напрямую расположение этой сетки, оставляя для неё значение по умолчанию — (0,0,0), относительно объекта `markerContainer`. Данное значение располагает хитбокс возле входного отверстия туннеля, в плоскости страницы с маркерами, где ранее располагалась бы удалённая нами сторона куба. 

Теперь, когда у нас есть в наличии хитбокс, который можно протестировать, мы создаём класс с названием `Reticle` для определения точки пересечения координат и отслеживания состояния. Его сообщения встраиваются в AR-изображение посредством подключения callback-функции при добавлении 
объекта через `arivew.add()`. Эта callback-функция запускается при 
выборе объекта, например:

    view.add( object, function(isSelected) {
        onMarkerSelectionChanged(marker.id, isSelected);
    });

Теперь игрок имеет возможность выбрать маркеры дополненной реальности, 
расположив их по центру экрана. 

## Рефакторинг

> git checkout example_9

> [демо][108], [дифф][109], [исходник примера][110]

С функциональностью дополненной реальности мы по сути закончили. У нас есть 
возможность распознать маркеры в фреймах вебкамеры и привязать к ним 3D-объекты. Также можно определить когда выбран маркер. Мы готовы перейти к второму ключевому компоненту игры «An AR Game»: плоскому двухмерному пространству, из которого пользователь перемещает игровые объекты. Для этого потребуется приличное количество кода, предварительная реорганизация кода может помочь сохранить его изящность. Обратите внимание, что большая часть функционала AR на данный момент помещена в главном файле application.js. Давайте его оттуда вырежем и поместим в отдельный модуль с названием [realspace.js][111], что сделает файл [application.js][112] намного чище. 

## Панель плоского пространства

> git checkout example_10

> [демо][113], [дифф][114], [исходник примера][115]

В игре «An AR Game» задача игрока состоит в перемещении игровых объектов из 
двухмерной плоскости в трёхмерное пространство. Модуль реального пространства, 
реализованный ранее, служит трёхмерным пространством. Наша двухмерная плоскость 
будет управляться модулем под названием flatspace.js, [создание которого 
начинается из каркасного шаблона][116], схожего с каркасом [application.js][117] и [realspace.js][118].

### Физика

> git checkout example_11

> [демо][119], [дифф][120], [исходник примера][121]

[Физика][122] представления реального пространства досталась нам на халяву, от 
[природы][123]. Однако, для панели плоского пространства используется симуляция двухмерной физики, а для её построения требуется промежуточное программное обеспечение, заточенное на расчеты такой физики. Мы будем 
использовать JavaScript-[транскомпиляцию][124] известного движка [Box2D][125] 
под названием [Box2D.js][126]. Версия на JavaScript берёт начало от исходного 
движка на [C++][127], пропущенного через [систему LLVM][128], и обработанного 
компилятором [emscripten][129].

Box2D — это часть довольно сложного ПО, однако для неё есть подробная 
[документация][130] и [описание возможностей][131]. Поэтому в этой статье я 
удержусь от повторения того, что итак уже исчерпывающе описано в других 
источниках. Вместо этого, я опишу распространённые проблемы при 
использовании Box2D, предложу решение нашей проблемы в виде модуля, и опишу  интеграцию данного модуля в flatspace.js.

Сперва построим [оболочку для исходного движка Box2D.js][132] и назовём её 
boxworld.js. Это будет то место, в котором наша программа [интегрируется в плоское пространство][133]. 

Никакого зримого визуального эффекта это не принесет, но, фактически, теперь у нас есть симуляция вакуума.

### Визуализация

Неплохо было бы иметь возможность видеть, что там происходит. Box2D предусмотрительно предоставляет возможность рендеринга отладки, а Box2D.js облегчает его с помощью чего-то, похожего на [виртуальные методы][134]. Методы будут отрисовывать контекст `canvas`, так что нам нужно создать полотно `canvas`, и, затем, предоставить для таблицы виртуальных методов поддержку отрисовки.

#### Шаг №1: Создаём метрический canvas

> git checkout example_12

> [демо][135], [дифф][136], [исходник примера][137]

Для преобразования данных из мира Box2D нам послужит `canvas`. Однако, единицей измерения для `canvas` служат пиксели, в то время как для описания пространства в Box2D используются метры. Нам потребуются методы для конвертации одних единиц в другие на основе [коэффициента пикселя к метру][138]. Методы конвертации используют константу для преобразования [пикселей в метры][139] и [метров в пиксели][140]. 
При помощи их мы также [выровняем исходные координаты][141]. Эти методы привязаны к `canvas` и обёрнуты в [модуль boxview.js][142]. Так его будет проще [встроить в плоское пространство][143]:

Модуль подвергается обработке при инициализации, затем его `canvas` добавляется в DOM:

    view = boxview.create({
        width:640, 
        height:480,
        pixelsPerMeter:13,
    });
 
    document.getElementById("flatspace").appendChild( view.canvas );

Теперь на странице есть два полотна `canvas` — плоское пространство и реальное 
пространство. Немного CSS в [application.css][144] располагает их рядом:

    #realspace {
        overflow:hidden;
    }
 
    #flatspace {
        float:left;
    }

#### Шаг 2: Собираем чертежный комплект

> git checkout example_13

> [демо][145], [дифф][146], [исходник примера][147]

Как уже упоминалось, Box2D.js предоставляет привязки для отрисовки отладочного 
эскиза мира. К ним можно получить доступ через [таблицу виртуальных методов][148] с помощью метода [`customizeVTable()`][149] и, впоследствии, вызвать с помощью [`b2World.DrawDebugData()`][150]. Мы позаимствуем методы отрисовки из описания [разработчика с псевдонимом kripken][151] и обернём их в модуль с названием [boxdebugdraw.js][152].

Теперь можно проводить отрисовку, но отрисовывать нам нечего. Сначала придётся 
ещё немного попотеть!

### Волокита

Мир Box2D населён объектами, которые называются телами. Тело, добавленное в мир Box2D, подчиняется законам физики, но, также оно должно подчиняться и правилам игры. 
Для этого мы создаём набор управляющих структур с данными и методами для управления телами. Их применение упрощает создание тела, определение столкновения и разрушение тела. Когда эти структуры добавлены, мы можем начать работу над реализацией логики проекта, создавая систему, в которой будет происходить игра.

#### Создание тела

> git checkout example_14

> [демо][153], [дифф][154], [исходник примера][155]

Давайте оживим имитацию, добавив созидательный момент. Код для построения тела 
Box2D довольно длинный, он включает в себя описание конструкций, форм и 
физических параметров. Так что мы будем хранить методы для создания тела в 
модуле [boxbody.js][156]. Чтобы создать тело, мы передаём [метод boxBody][157] в [`boxworld.add()`][158]. [Например:][159]

    function populate() {
        var ball = world.add(
            boxbody.ball,
            {
                x:0,
                y:8,
                radius:10
            }
        );
    }

Это даёт нам неоформленный шар в воздухе, испытывающий воздействие гравитации. Если задуматься, он напоминает [одного кита][160]. 

#### Регистрация

> git checkout example_15

> [демо][161], [дифф][162], [исходник примера][163]

Нам необходима возможность ведения учёта тел, которые населяют плоский мир. 
Box2D предоставляет доступ к списку тел, но он слишком базовый, чтобы 
удовлетворить наши потребности. Вместо этого мы используем поле `b2Body` под 
названием `userData`. Мы присвоим ему уникальный номер, который впоследствии 
будет использоваться как индекс в регистре нашего проекта. Он выполняется в 
boxregistry.js, и является ключевым аспектом реализации плоского пространства. 
Данный индекс делает возможной привязку к декоративным сущностям (таким, как спрайты), и упрощает создание callback-функций для расчета столкновений, а также облегчает удаление тел из симуляции. Подробности реализации здесь описаны не будут, но заинтересованные читатели могут просмотреть репозиторий на предмет [обработки регистра][164] в boxworld.js, и возвращения [методом `add()`][165] [тел с обёрткой, занесённых в регистр][166]. 

#### Столкновение

> git checkout example_16

> [демо][167], [дифф][168], [исходник примера][169]

Определение столкновения в Box2D усложнено тем, что встроенная callback-функция даёт две фиксированные величины, необработанные и неупорядоченные, и мы получаем уведомление о всех столкновениях, происходящих в мире, тем самым 
сталкиваясь с необходимостью проведения многочисленных условных проверок. Модуль boxregistry.js подходит для управления перегруженными данными. Он позволяет присвоить зарегистрированным объектам [callback-функцию `onContact`][170]. Когда запущен Box2D-обработчик столкновения, [мы отправляем в регистр запрос на соответствующие объекты][171] и проверяем [наличие callback-функции][172]. Если для объекта определена callback-функция, мы знаем что его 
активность представляет для нас интерес. Чтобы использовать этот алгоритм в flatspace.js, нужно просто [присвоить зарегистрированному объекту callback-функцию при столкновении][173]:

    function populate() {
        var ground = world.add(
            boxbody.edge,
            {
                x:0,
                y:-15,
                width:20,
                height:0,
            }
        );
 
        var ball = world.add(
            boxbody.ball,
            {
                x:0,
                y:8,
                radius:10
            }
        );
 
        ball.onContact = function(object) {
            console.log("Шар вступил в контакт с:", object);
        };
    }

#### Удаление

> git checkout example_17

> [демо][174], [дифф][175], [исходник примера][176]

Удаление тел осложнено тем, что Box2D не разрешает обращения к 
`b2World.DestroyBody()` из `b2World.Step()`. Это важно, поскольку обычно тело 
нужно удалить вследствии столкновения, а callback-функция столкновения 
встречается в симуляции именно на этом этапе, вот такая вот задачка. 
Одно из решений — ставить тела в очередь на удаление, а затем подвергать эту очередь обработке за пределами данного этапа симуляции. `boxregistry` предоставляет решение для этой проблемы посредством установки флага [`isMarkedForDeletion`][177] для каждого объекта. Происходит [перебор списка зарегистрированных объектов и обработчики получают извещение о запросе на удаление][178]. Итерация [происходит после этапа симуляции столкновения][179], так что [функция удаления полностью уничтожает тела][180]. Проницательные читатели возможно догадались, что теперь [перед вызовом функции столкновения мы проверяем флаг `isMarkedForDeletion`][181]. 

Когда речь идёт о flatspace.js, всё происходит прозрачно, так что от нас 
требуется только [установить флаг удаления для зарегистрированного объекта][182]:

    ball.onContact = function(object) {
        console.log("Шар вступил в контакт с:", object);
        ball.isMarkedForDeletion = true;
    };

Теперь тело удаляется при контакте с поверхностью.

#### Распознавание

> git checkout example_18

> [демо][183], [дифф][184], [исходник примера][185]

Когда определено столкновение, игре нужно знать, с чем именно столкнулся объект. Для этого мы добавим [для зарегистрированных объектов метод `is()`][186], который используется для сравнения объектов. Теперь добавим в игру условие для удаления:

    ball.onContact = function(object) {
        console.log("Шар вступил в контакт с:", object);
        if( object.is( ground ) ) {
            ball.isMarkedForDeletion = true;
        }
    };

### Двухмерный туннель

> git checkout example_19

> [демо][187], [дифф][188], [исходник примера][189]

Мы уже обсудили туннели в реальном пространстве, теперь нужно реализовать их 
копии в плоском пространстве. Туннель в плоском пространстве представляет собой тело, состоящее из датчика Box2D. Шар должен пройти *над* закрытым туннелем, но *через* открытый туннель. Теперь представьте крайний случай, когда шар проходит над закрытым туннелем, который затем открывается. Проблема состоит в том, что обработчик `onBeginContact` ведёт себя согласно своему названию. Контакт с туннелем был определён при закрытом состоянии, после чего туннель был открыт. Следовательно траектория шара не искривляется и мы получаем ошибку. Решить это можно, используя совокупность нескольких датчиков. При использовании совокупности датчиков мы получаем цепочку событий `BeginContact` по мере движения шара над туннелем. Так 
мы можем быть уверены, что открытие туннеля, когда шар движется над ним, приведет к изменению траектории шара. Генератор совокупности датчиков называется [`hole` и реализован в boxbody.js][190]. Сгенерированная совокупность датчиков выглядит так:

![Сгенерированная совокупность датчиков][пример]

## Трубопровод

На данный момент мы подготовили к использованию модули на основе JSARToolkit и 
Box2D.js. Мы использовали их, чтобы создать туннель в реальном и плоском пространствах. Целью игры является перемещение игровых объектов из 
плоского пространства в реальное пространство, и потому нам нужно обеспечить обмен данными между этими туннелями. Мы подойдём к этому так:

1. `git checkout example_20`

[демо][191], [дифф][192], [исходник примера][193]

Уведомляем приложение об изменении состояния туннеля в реальном пространстве.

2. `git checkout example_21`

[демо][194], [дифф][195], [исходник примера][196]

Синхронизируем состояние туннеля в плоском пространстве с состоянием туннеля в 
реальном пространстве.

3. `git checkout example_22`

[демо][197], [дифф][198], [исходник примера][199]

Уведомляем приложение, когда шар проходит через открытый туннель в плоском 
пространстве.

4. `git checkout example_23`

[демо][200], [дифф][201], [исходник примера][202]

Добавляем шар в реальном пространстве когда приложение получает уведомление о 
прохождении.

## Заключение

В этой статье показана техническая основа игры «An AR Game». Мы создали две 
панели различающихся реальностей и соединили их туннелем. Игрок теперь может 
развлекаться, перемещая шар из плоского пространства в реальное пространство. С технической точки зрения это интересно, но, в общем, не особо весело. 

Ещё много предстоит сделать, чтобы это приложение стало игрой, но это уже выходит за пределы темы этой статьи. Нерешёнными остаются такие задачи как:

* Спрайты и анимация.
* Введение нескольких шаров и туннелей.
* Предоставление возможности интерактивной проектировки уровней.

Спасибо за чтение этой статьи! Надеюсь, что мы вдохновили вас на дальнейшее 
изучение этой темы!

[1]: https://developer.mozilla.org/fr/demos/detail/an-ar-game
[2]: https://developer.mozilla.org/en/demos/devderby/2013/may
[3]: https://developer.mozilla.org/en/demos/devderby
[4]: http://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C
[5]: http://abrie.github.io/devderby-may-2013/
[6]: http://www.youtube.com/watch?v=Pa_EwQ0DoWk
[7]: http://dev.w3.org/2011/webrtc/editor/getusermedia.html
[8]: https://github.com/kig/JSARToolKit
[9]: https://github.com/mrdoob/three.js/
[10]: https://github.com/kripken/box2d.js
[11]: https://github.com/abrie/devderby-may-2013-technical
[12]: https://github.com/abrie/devderby-may-2013-technical/tags
[13]: http://abrie.github.io/devderby-may-2013-technical/
[14]: #realspace
[15]: #flatspace
[16]: #conduit
[17]: http://abrie.github.io/devderby-may-2013-technical/example_0/application.html
[18]: https://github.com/abrie/devderby-may-2013-technical/commit/bef8bf5c6505e30a3fc9ad0f2f4564df060c4296
[19]: https://github.com/abrie/devderby-may-2013-technical/tree/example_0
[20]: http://requirejs.org/
[21]: https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame
[22]: http://abrie.github.io/devderby-may-2013-technical/example_1/application.html
[23]: https://github.com/abrie/devderby-may-2013-technical/commit/4d7f2faa18b794be4bd0a10d4fa0c6dfa306e519
[24]: https://github.com/abrie/devderby-may-2013-technical/tree/example_1
[25]: http://ru.wikipedia.org/wiki/HTML5
[26]: http://ru.wikipedia.org/wiki/WebRTC
[27]: http://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D0%B0
[28]: http://www.mozilla.org/ru/firefox/new/
[29]: https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getUserMedia
[30]: https://developer.mozilla.org/en-US/
[31]: http://requirejs.org/docs/api.html#define
[32]: https://github.com/abrie/devderby-may-2013-technical/blob/master/webcam.js
[33]: https://github.com/abrie/devderby-may-2013-technical/commit/4d7f2faa18b794be4bd0a10d4fa0c6dfa306e519/#L0R32
[34]: https://github.com/abrie/devderby-may-2013-technical/commit/4d7f2faa18b794be4bd0a10d4fa0c6dfa306e519/#L0R25
[35]: http://abrie.github.io/devderby-may-2013-technical/example_2/application.html
[36]: https://github.com/abrie/devderby-may-2013-technical/commit/388378463230b28c333b4954154f087919d7a3c2
[37]: https://github.com/abrie/devderby-may-2013-technical/tree/example_2
[38]: http://en.wikipedia.org/wiki/Fiduciary_marker
[39]: https://github.com/kig/JSARToolKit/tree/master/demos/markers
[40]: http://www.hitl.washington.edu/artoolkit/
[41]: http://ru.wikipedia.org/wiki/C%2B%2B
[42]: http://ru.wikipedia.org/wiki/%D0%92%D0%B0%D1%88%D0%B8%D0%BD%D0%B3%D1%82%D0%BE%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%82%D0%B5%D1%82
[43]: http://www.hitl.washington.edu/home/
[44]: http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%8D%D1%82%D0%BB
[45]: http://nyatla.jp/nyartoolkit/wp/?page_id=198
[46]: http://www.libspark.org/wiki/saqoosha/FLARToolKit/en
[47]: https://github.com/kig/JSARToolKit
[48]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/ardetector.js#L10
[49]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/ardetector.js#L24
[50]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/ardetector.js#L65
[51]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L34
[52]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L47
[53]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L34
[54]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L47
[55]: http://abrie.github.io/devderby-may-2013-technical/example_3/application.html
[56]: https://github.com/abrie/devderby-may-2013-technical/commit/c9de6aaf6805c760bbab6671126c323ac4227dad
[57]: https://github.com/abrie/devderby-may-2013-technical/tree/example_3
[58]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L19
[59]: https://developer.mozilla.org/en-US/docs/Web/WebGL?redirectlocale=en-US&redirectslug=WebGL
[60]: https://github.com/abrie/devderby-may-2013-technical/blob/example_3/arview.js#L11
[61]: https://github.com/abrie/devderby-may-2013-technical/blob/example_3/arview.js#L14
[62]: https://github.com/abrie/devderby-may-2013-technical/blob/example_3/application.js#L31
[63]: http://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88
[64]: #example_2
[65]: http://abrie.github.io/devderby-may-2013-technical/example_4/application.html
[66]: https://github.com/abrie/devderby-may-2013-technical/commit/e16eb6c510d3f0e38b66057befa51406b516e38c
[67]: https://github.com/abrie/devderby-may-2013-technical/tree/example_4
[68]: http://www.youtube.com/watch?v=g4n9lebq_Kg&feature=youtu.be
[69]: http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%B0
[70]: http://en.wikipedia.org/wiki/Camera_matrix
[71]: https://github.com/abrie/devderby-may-2013-technical/blob/master/ardetector.js
[72]: https://developer.mozilla.org/en-US/docs/Web/API/Float32Array?redirectlocale=en-US&redirectslug=Web%2FJavaScript%2FTyped_arrays%2FFloat32Array
[73]: http://ru.wikipedia.org/wiki/Monkey_patch
[74]: http://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88
[75]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/arobject.js#L21
[76]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/arobject.js#L16
[77]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/arobject.js#L19
[78]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/application.js#L57
[79]: http://abrie.github.io/devderby-may-2013-technical/example_5/application.html
[80]: https://github.com/abrie/devderby-may-2013-technical/commit/1c28aa84b7559cdd46f04d31ef94abb7b7136854
[81]: https://github.com/abrie/devderby-may-2013-technical/tree/example_5
[82]: http://www.youtube.com/watch?v=50nYnIBJtTg&feature=youtu.be
[83]: https://github.com/abrie/devderby-may-2013-technical/blob/example_5/arobject.js#L35
[84]: https://github.com/abrie/devderby-may-2013-technical/blob/example_5/arobject.js#L29
[85]: https://github.com/abrie/devderby-may-2013-technical/blob/example_5/arobject.js#L38
[86]: http://abrie.github.io/devderby-may-2013-technical/example_6/application.html
[87]: https://github.com/abrie/devderby-may-2013-technical/commit/0e4f2d5b9058425cbf61befabb510df20d5563ac
[88]: https://github.com/abrie/devderby-may-2013-technical/tree/example_6
[89]: http://www.youtube.com/watch?v=BtAxElxQiFk&feature=youtu.be
[90]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arobject.js#L44
[91]: #step3
[92]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arobject.js#L46
[93]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arview.js#L78
[94]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arview.js#L75
[95]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arview.js#L85
[96]: http://abrie.github.io/devderby-may-2013-technical/example_7/application.html
[97]: https://github.com/abrie/devderby-may-2013-technical/commit/81b4a4ae2c44a910b319eff43edd7b1f8ea1651c
[98]: https://github.com/abrie/devderby-may-2013-technical/tree/example_7
[99]: http://www.youtube.com/watch?v=GM5eu3NBMZY&feature=youtu.be
[100]: https://github.com/abrie/devderby-may-2013-technical/blob/example_7/arview.js#L90
[101]: https://github.com/abrie/devderby-may-2013-technical/blob/example_7/arview.js#L85
[102]: http://abrie.github.io/devderby-may-2013-technical/example_8/application.html
[103]: https://github.com/abrie/devderby-may-2013-technical/commit/3f236ed4f79704be9733cba55efd4f4c47a35ef5
[104]: https://github.com/abrie/devderby-may-2013-technical/tree/example_8
[105]: http://ru.wiktionary.org/wiki/caveat
[106]: https://github.com/abrie/devderby-may-2013-technical/blob/example_8/arobject.js#L78
[107]: https://github.com/abrie/devderby-may-2013-technical/blob/example_8/arobject.js#L43
[108]: http://abrie.github.io/devderby-may-2013-technical/example_9/application.html
[109]: https://github.com/abrie/devderby-may-2013-technical/commit/005f87d6c40322309ad9a68d4b2627cc6599684d
[110]: https://github.com/abrie/devderby-may-2013-technical/tree/example_9
[111]: https://github.com/abrie/devderby-may-2013-technical/blob/example_9/realspace.js
[112]: https://github.com/abrie/devderby-may-2013-technical/blob/example_9/application.js
[113]: http://abrie.github.io/devderby-may-2013-technical/example_10/application.html
[114]: https://github.com/abrie/devderby-may-2013-technical/commit/1ae5a00a63d0a6def6aeeab1f6d6fa7552f9d488
[115]: https://github.com/abrie/devderby-may-2013-technical/tree/example_10
[116]: https://github.com/abrie/devderby-may-2013-technical/blob/example_10/flatspace.js
[117]: https://github.com/abrie/devderby-may-2013-technical/blob/example_0/application.js
[118]: https://github.com/abrie/devderby-may-2013-technical/blob/example_9/realspace.js
[119]: http://abrie.github.io/devderby-may-2013-technical/example_11/application.html
[120]: https://github.com/abrie/devderby-may-2013-technical/commit/23e97233b1da08b4aebedd96917e406613286c1a
[121]: https://github.com/abrie/devderby-may-2013-technical/tree/example_11
[122]: http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B2%D0%B8%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5
[123]: http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D1%80%D0%BE%D0%B4%D0%B0
[124]: http://en.wikipedia.org/wiki/Source-to-source_compiler
[125]: http://ru.wikipedia.org/wiki/Box2D
[126]: https://github.com/kripken/box2d.js/
[127]: https://code.google.com/p/box2d/
[128]: http://ru.wikipedia.org/wiki/Low_Level_Virtual_Machine
[129]: https://github.com/kripken/emscripten
[130]: http://box2d.org/manual.pdf
[131]: http://box2d.org/manual.pdf
[132]: https://github.com/abrie/devderby-may-2013-technical/blob/example_11/boxworld.js
[133]: https://github.com/abrie/devderby-may-2013-technical/commit/23e97233b1da08b4aebedd96917e406613286c1a#diff-19f884bd80981aedf202452cae4fc0f0
[134]: http://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4
[135]: http://abrie.github.io/devderby-may-2013-technical/example_12/application.html
[136]: https://github.com/abrie/devderby-may-2013-technical/commit/dfa4fee9ccb3a40d17b7678adfdeb0d87a63420b
[137]: https://github.com/abrie/devderby-may-2013-technical/tree/example_12
[138]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L9
[139]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L24
[140]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L31
[141]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L12
[142]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js
[143]: https://github.com/abrie/devderby-may-2013-technical/commit/dfa4fee9ccb3a40d17b7678adfdeb0d87a63420b#diff-19f884bd80981aedf202452cae4fc0f0
[144]: https://github.com/abrie/devderby-may-2013-technical/blob/7d2c4de27aa3ed5b04ab1b02c0e79643a51e17f2/application.css
[145]: http://abrie.github.io/devderby-may-2013-technical/example_13/application.html
[146]: https://github.com/abrie/devderby-may-2013-technical/commit/806d65ceca9707463a1cdfebc9d8feef433d85eb
[147]: https://github.com/abrie/devderby-may-2013-technical/tree/example_13
[148]: http://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2
[149]: https://github.com/kripken/box2d.js/#using-debug-draw
[150]: https://github.com/abrie/devderby-may-2013-technical/blob/example_13/boxdebugdraw.js#L181
[151]: https://github.com/kripken/box2d.js/#using-debug-draw
[152]: https://github.com/abrie/devderby-may-2013-technical/blob/example_13/boxdebugdraw.js
[153]: http://abrie.github.io/devderby-may-2013-technical/example_14/application.html
[154]: https://github.com/abrie/devderby-may-2013-technical/commit/b7117c1914941514855e01ee1a9573b853f4811a
[155]: https://github.com/abrie/devderby-may-2013-technical/tree/example_14
[156]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/boxbody.js
[157]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/boxbody.js#L5
[158]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/boxworld.js#L13
[159]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/flatspace.js#L33
[160]: http://ru.wikipedia.org/wiki/%D0%92%D1%82%D0%BE%D1%80%D0%BE%D1%81%D1%82%D0%B5%D0%BF%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0%D0%B6%D0%B8_%D0%B2_%C2%AB%D0%90%D0%B2%D1%82%D0%BE%D1%81%D1%82%D0%BE%D0%BF%D0%BE%D0%BC_%D0%BF%D0%BE_%D0%B3%D0%B0%D0%BB%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B5%C2%BB#.D0.9A.D0.B0.D1.88.D0.B0.D0.BB.D0.BE.D1.82
[161]: http://abrie.github.io/devderby-may-2013-technical/example_15/application.html
[162]: https://github.com/abrie/devderby-may-2013-technical/commit/04a86c1b28b642d876dd7e80947f361718c120d6
[163]: https://github.com/abrie/devderby-may-2013-technical/tree/example_15
[164]: https://github.com/abrie/devderby-may-2013-technical/blob/example_15/boxworld.js#L8
[165]: https://github.com/abrie/devderby-may-2013-technical/blob/example_15/boxworld.js#L14
[166]: https://github.com/abrie/devderby-may-2013-technical/blob/example_15/boxworld.js#L16
[167]: http://abrie.github.io/devderby-may-2013-technical/example_16/application.html
[168]: https://github.com/abrie/devderby-may-2013-technical/commit/d6a6657060d040bec2a002deac34d03e81122d25
[169]: https://github.com/abrie/devderby-may-2013-technical/tree/example_16
[170]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/boxregistry.js#L20
[171]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/boxworld.js#L38
[172]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/boxworld.js#L41
[173]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/flatspace.js#L52
[174]: http://abrie.github.io/devderby-may-2013-technical/example_17/application.html
[175]: https://github.com/abrie/devderby-may-2013-technical/commit/9d9c2b91c7c7f55610d0b8459eccc76c4381c554
[176]: https://github.com/abrie/devderby-may-2013-technical/tree/example_17
[177]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxregistry.js#L22
[178]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxregistry.js#L50
[179]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxworld.js#L26
[180]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxworld.js#L18
[181]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxworld.js#L48
[182]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/flatspace.js#L54
[183]: http://abrie.github.io/devderby-may-2013-technical/example_18/application.html
[184]: https://github.com/abrie/devderby-may-2013-technical/commit/682aa2b215e6d918393d03dd103f3338c59a2be0
[185]: https://github.com/abrie/devderby-may-2013-technical/tree/example_18
[186]: https://github.com/abrie/devderby-may-2013-technical/blob/example_18/boxregistry.js#L23
[187]: http://abrie.github.io/devderby-may-2013-technical/example_19/application.html
[188]: https://github.com/abrie/devderby-may-2013-technical/commit/736662188f65cbdb6aae7572ffcc46d1ced38253
[189]: https://github.com/abrie/devderby-may-2013-technical/tree/example_19
[190]: https://github.com/abrie/devderby-may-2013-technical/blob/example_19/boxbody.js#L42
[191]: http://abrie.github.io/devderby-may-2013-technical/example_20/application.html
[192]: https://github.com/abrie/devderby-may-2013-technical/commit/ada13bcf70b633a06afbad065d2cdea6b86baeb2
[193]: https://github.com/abrie/devderby-may-2013-technical/tree/example_20
[194]: http://abrie.github.io/devderby-may-2013-technical/example_21/application.html
[195]: https://github.com/abrie/devderby-may-2013-technical/commit/b93aab3db72cdcd004d1048c9a7e8b097ced547f
[196]: https://github.com/abrie/devderby-may-2013-technical/tree/example_21
[197]: http://abrie.github.io/devderby-may-2013-technical/example_22/application.html
[198]: https://github.com/abrie/devderby-may-2013-technical/commit/7d1c2a2ce676f19a1970ce254eeecbeced299a34
[199]: https://github.com/abrie/devderby-may-2013-technical/tree/example_22
[200]: http://abrie.github.io/devderby-may-2013-technical/example_23/application.html
[201]: https://github.com/abrie/devderby-may-2013-technical/commit/05b6bf16fa2da753ddfd9a777a5523e2272df693
[202]: https://github.com/abrie/devderby-may-2013-technical/tree/example_23

[маркеры]: img/AR-Game-16_and_32.png
[Страница с маркерами]: img/AR-Game-example_3.png
[кубики]: img/AR-Game-example_4.png
[незаконченный эффект]: img/AR-Game-example_5.png
[синий]: img/AR-Game-example_6.png
[Иллюзия]: img/AR-Game-example_7.png
[пример]: img/sensor-cluster.png