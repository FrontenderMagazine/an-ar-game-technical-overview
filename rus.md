# Игра с дополненной реальностью: технический обзор

Игра [«An AR Game»][1] — победитель в конкурсе приложений [Dev Derby][3] в [марте 2013 года][2]. Она представляет собой игру с [дополнительной реальностью][4] (далее «ДР»), цель которой состоит в перемещении катящихся игровых элементов из мира с двухмерной физикой в трёхмерное пространство. Вы можете [поиграть в эту игру на GitHub][5] и [посмотреть её презентацию на YouTube][6]. Задача этой статьи — описать дизайнерские и инженерные приёмы, которые легли в основу игры.

Технически игра является простым соединением четырех сложных технологий с открытым исходным кодом: [WebRTC][7], [JSARToolkit][8], [ThreeJS][9] и [Box2D.js][10]. В этой статье описана каждая из них и объяснено как они сливаются в одно целое. Мы будем работать поэтапно, создавая игру с нуля. Код, рассмотренный в этой статье, размещён на [github][11], на каждом этапе этого урока предоставлены ссылки на соответствующую [метку][12] и [демо][13]-страницу. Некоторые обобщённые отрывки исходного кода будут представлены в статье, полный код находится по ссылке «диффы». Также по возможности предложены ссылки на видео-ролики, демонстрирующие поведение приложения. 

> git clone https://github.com/abrie/devderby-may-2013-technical.git

В начале этой статьи будет рассмотрена панель ДР ([реальное пространство][14]), затем 2D-панель ([плоское пространство][15]) и в завершение будет представлено описание их [соединения][16].

## Панель реального пространства

Реальное пространство — это то, что видит камера, на него налагаются виртуальные объекты. 

### Начнём со скелета

> git checkout example_0
> [демо][17], [дифф][18], [метка][19]

Мы разобьем весь код на модули используя [RequireJS][20]. Отправной точкой послужит главный модуль с двумя каркасными методами, которые часто используются в играх. Это `initialize()`, вызывающий запуск и `tick()` для отрисовки каждого фрейма. Обратите внимание, что игровой цикл приводится в действие посредством повторяющихся обращений к [`requestAnimationFrame`][21]:

    requirejs([], function() {
 
        // Инициализация компонентов и начало игрового цикла 
        function initialize() {
        }
 
        // Выполнение одной итерации игрового цикла 
        function tick() {
            // Запрос следующей итерации игрового цикла 
            window.requestAnimationFrame(tick);
        }
 
        // Запуск приложения 
        initialize();
        tick();
    });

На данном этапе код даёт нам приложение с пустым циклом. Продолжим разработку используя эту основу. 

### Наделяем скелет зрением

> git checkout example_1
> [демо][22], [дифф][23], [метка][24]

Для игр с ДР необходим видеопоток реального времени. [WebRTC][26] на основе [HTML5][25] предоставляет его, обеспечивая доступ к [вебкамере][27]; следовательно игры с ДР возможны в современных браузерах вроде [Firefox][28]. Подробная документация по WebRTC и [getUserMedia][29] выложена на [developer.mozilla.org][30], так что мы не будет излагать здесь основы.

Библиотека для камеры представлена в форме модуля [RequireJS][31] под названием [webcam.js][32], который мы встроим в наш пример.

Сначала камера должна быть включена и доступ к ней должен быть авторизирован. Модуль webcam.js [после получения согласия пользователя запускает функцию обратного вызова][33], затем после каждого запроса итерации игрового цикла [фрейм копируется из элемента `video` в `context` для `canvas`][34]. Это важно, так как таким образом видеоданные становятся доступными. Мы используем это в последующих разделах, а пока наше приложение представляет собой просто `canvas`, в котором обновляется видео-фрейм после каждого запроса итерации.

### Имитируем зрительную зону коры головного мозга

> git checkout example_2
> [демо][35], [дифф][36], [метка][37]

JSARToolkit — это движок дополненной реальности. Он определяет и описывает положение координатных меток на изображении. У каждой метки есть свой уникальный номер. Маркеры, которые распознаются библиотекой JSARToolkit представлены [здесь][39] в виде PNG-изображений, пронумерованных согласно их уникальному номеру (хотя на момент написания этой статьи отсутствие расширения .PNG и сбивает Github с толку.) Для этой игры мы будем использовать №16 и №32, объединённых на одной странице: 

![Маркеры №16 и №32, объединённые на одной странице][маркеры]

JSARToolkit походит от [ARToolkit][40], который был написан в [C++][41] в лаборатории [HITLab][43] [Вашингтонского университета][42] в [Сиэтле][44]. Он был скопирован и перенесён на ряд других языков, в том числе [Java][45], затем с Java на [Flash][46], и наконец с Flash на [JS][47]. Такое происхождение привело к некоторым особенностям и непоследовательности названий, как будет видно дальше. 

Давайте взглянем на функциональное наполнение:

    // Объект raster — это canvas, в который мы копируем видео-фреймы.
     var JSARRaster = NyARRgbRaster_Canvas2D(canvas);
 
     // Объект parameters обозначает размеры входящего потока в пикселях.
     var JSARParameters = new FLARParam(canvas.width, canvas.height);
 
     // MultiMarkerDetector — движок для распознавания маркера
     var JSARDetector = new FLARMultiIdMarkerDetector(FLARParameters, 120);
     JSARDetector.setContinueMode(true);
 
     // Запуск детектора для фрейма, который возвращает количество распознанных маркеров.
     var threshold = 64;
     var count = JSARDetector.detectMarkerLite(JSARRaster, threshold);

После обработки фрейма `JSARDetector.detectMarkerLite()`, объект `JSARDetector` содержит список распознанных маркеров. `JSARDetector.getIdMarkerData(index)` возвращает уникальный номер, а `JSARDetector.getTransformMatrix(index)` — положение в пространстве. Эти методы непростые в использовании, но мы [обернём их в][48] [удобные вспомогательные методы][49] и вызовем из цикла таким способом:

    var markerCount = JSARDetector.detectMarkerLite(JSARRaster, 90); 
 
    for( var index = 0; index &lt; markerCount; index++ ) {
        // Получение уникального номера распознанного маркера.
        var id = getMarkerNumber(index);
 
        // Получение матрицы перехода для распознанного маркера.
        var matrix = getTransformMatrix(index);
    }

Поскольку детектор работает на пофреймовой основе, ответственность за состояние маркера в промежутках между фреймами ложится на нас. Например, между двумя последовательными фреймами может случиться любое из следующего:

* распознание нового маркера;
* изменение расположения существующего маркера;
* исчезновение существующего маркера из потока.

Отслеживание состояния [реализуется с помощью ardetector.js][50]. Для этого мы создаем копию `canvas`, в который передаются видеофреймы:

    // Создаем детектор маркера ДР, используя canvas в качестве источника данных
    var detector = ardetector.create( canvas );

С каждым запросом итерации [изображение в `canvas` сканируется детектором][51] и [при необходимости запускается функция обратного вызова][52]:

    // Распоряжение для детектора выполнить распознание. 
    detector.detect( onMarkerCreated, onMarkerUpdated, onMarkerDestroyed );

Как видно по коду, теперь наше приложение [распознаёт маркеры][53] и [выводит результаты своих открытий в консоль][54].

### Реальность как плоскость

> git checkout example_3
> [демо][55], [дифф][56], [метка][57]

Представление дополненной реальности состоит из *реального* изображения, на которое накладываются 3D-модели. Воспроизведение такого представления обычно делится на два этапа. Первый этап — воспроизведение *реального* изображения, уловленного камерой. В предыдущих примерах [мы просто скопировали это изображение в `canvas`][58]. Но нам нужно дополнить представление 3D-моделями, а для этого нужен холст [WebGL][59]. Задача усложнена тем, что у WebGL холста нет контекста `context`, в который можно было бы скопировать изображение. Вместо этого мы будем передавать в WebGL сцену [текстурированную плоскость][60], используя изображения с вебкамеры в качестве текстуры. ThreeJS может воспринимать `canvas` как источник с текстурой, так что [мы можем вводить в него `canvas`][61], [в который передаются видеофреймы][62]:

    // Создаём текстуру texture, связанную с canvas.
    var texture = new THREE.Texture(canvas);

ThreeJS кеширует текстуры, следовательно каждый раз когда видеофрейм копируется в `canvas`, должен быть установлен флаг, обозначающий что текстура в кеше должна быть обновлена: 

    // Когда текстура изменилась, нам нужно сообщить об этом ThreeJS 
    function update() {
        texture.needsUpdate = true;
    }

![Страница с маркерами почти готова к тому чтобы быть дополненной][Страница с маркерами]

Это даёт нам приложение, которое, с точки зрения пользователя, ничем не отличается от [примера №2][64]. Однако за кадром сплошной WebGL; следующий шаг — дополнить его!

### Дополняем реальность

> git checkout example_4
> [демо][65], [дифф][66], [метка][67], [видео][68]

Мы готовы добавить в нашу смесь дополненные компоненты: они примут форму 3D-моделей, выровненных согласно маркеров, зафиксированных камерой. Сначала нам нужно разрешить обмен данными между детектором `ardetector` и ThreeJS, это даст нам возможность построить модели, которыми можно дополнить координатные метки.

#### Шаг 1. Пересчёт трансформации

Программисты, знакомые с 3D-графикой, знают, что для отрисовки нужны две матрицы: модельная матрица ([матрица трансформации][69]) и матрица камеры ([проекционная матрица][70]). Их можно получить используя [ardetector][71], внедрённый ранее, но их нельзя использовать без изменений — массивы матриц, предоставленные ardetector несовместимы с ThreeJS. Например, вспомогательный метод `getTransformMatrix()` возвращает массив [Float32Array][72], который ThreeJS не понимает. К счастью их можно легко конвертировать через расширение прототипа, также известного под названием [«обезьяний патч»][73]:

    // Разрешаем установку Matrix4 с помощью Float32Array
    THREE.Matrix4.prototype.setFromArray = function(m) {
     return this.set(
      m[0], m[4], m[8],  m[12],
      m[1], m[5], m[9],  m[13],
      m[2], m[6], m[10], m[14],
      m[3], m[7], m[11], m[15]
     );
    }

Это даёт нам возможность настроить матрицу трансформации, но на практике мы увидим что обновление не приносит никакого эффекта. Причина этому — [кеширование][74] ThreeJS. Чтобы привести в действие такие изменения, мы создадим объект-контейнер и [установим значение `false` для флага `matrixAutoUpdate`][75]. Затем при каждом обновлении в матрице  [устанавливаем для `matrixWorldNeedsUpdate` значение `true`][76].

#### Шаг 2. Куб обозначает маркер

Теперь используем наши обезьяньи патчи и объекты-контейнеры чтобы отобразить разноцветные кубики как дополненные маркеры. Сначала создадим сетку куба, с размерами, подходящими для координатной метки: 

    function createMarkerMesh(color) {
        var geometry = new THREE.CubeGeometry( 100,100,100 );
        var material = new THREE.MeshPhongMaterial( {color:color, side:THREE.DoubleSide } );
 
        var mesh = new THREE.Mesh( geometry, material );                      
 
        //Отрицательное значение, равное половине высоты объекта, располагает объект над маркером ДР.
        mesh.position.z = -50; 
 
        return mesh;
    }

Затем поместим сетку в [объект-контейнер][77]: 

    function createMarkerObject(params) {
        var modelContainer = createContainer();
 
        var modelMesh = createMarkerMesh(params.color);
        modelContainer.add( modelMesh );
 
        function transform(matrix) {
            modelContainer.transformFromArray( matrix );
        }
    }

Дальше генерируем маркерные объекты, каждый из которых соответствует уникальному номеру маркера:

    // Создаём маркерные объекты, соответствующие желаемому уникальному номеру маркера.
        var markerObjects = {
            16: arobject.createMarkerObject({color:0xAA0000}), // Маркер #16, красный.
            32: arobject.createMarkerObject({color:0x00BB00}), // Маркер #32, зелёный.
        };

Функции обратного вызова `ardetector.detect()` [применяют матрицу трансформации к соответствующему маркеру][78]. Например, здесь обработчик `onCreate` добавляет трансформированную модель в представление ДР:

    // Эта функция вызывается когда маркер впервые распознаётся в потоке
    function onMarkerCreated(marker) {
        var object = markerObjects[marker.id];
 
        // Установка исходной матрицы трансформации для объекта.
        object.transform( marker.matrix );
 
        // Добавление объекта к сцене.
        view.add( object );
    }
    });

![Теперь наше приложение представляет собой функционирующий пример дополненной реальности][кубики]

Теперь наше приложение представляет собой функционирующий пример дополненной реальности!

### Создаём отверстия

В игре «An AR Game» маркеры более сложны, чем просто разноцветные кубики. Они являются своеобразными туннелями, которые визуально входят внутрь страницы с маркером. Чтобы создать такой эффект, нам придётся применить немного хитростей, так что для наглядности мы создадим его в три шага. 

#### Шаг 1: Открытие куба

> git checkout example_5
> [демо][79], [дифф][80], [метка][81], [видео][82]

Сначала создадим открытую коробку удалив верхнюю стенку куба. Этого можно добиться [сделав материал стенки][83] [невидимым][84]. Открытая коробка расположена *позади/под* листом с маркером [благодаря тому, что координаты по оси Z равны половине высоты коробки][85].

![Получаем интересный, но незаконченный эффект — и вероятно не сразу понятно в чём дело][незаконченный эффект]

Получаем интересный, но незаконченный эффект — и вероятно не сразу понятно в чём дело.

#### Шаг 2. Покрываем куб синим цветом

> git checkout example_6
> [демо][86], [дифф][87], [метка][88], [видео][89]

Итак, что мы пропустили? Нам нужно спрятать ту часть коробки, которая должна быть *сзади* листа с маркером. Этого можно достичь, заключив коробку в [коробку побольше][90] для начала. Назовем эту коробку «блокатором», в [шаге №3][91] она будет играть роль плаща-невидимки. Пока оставим её [видимой и закрасим синим цветом][92] для наглядности. 

[Объекты-блокаторы][93] и [объекты дополненной реальности][94] воспроизводятся в одном контексте, но отдельных сценах: 

    function render() {
        // Отрисовка реальной сцены 
        renderer.render(reality.scene, reality.camera);
 
        // Отрисовка сцены с блокатором 
        renderer.render( occluder.scene, occluder.camera);
 
        // Отрисовка компонентов дополненной реальности поверх реальной сцены.
        renderer.render(virtual.scene, virtual.camera);
    }

![Прячем ту часть коробки, которая должна быть сзади листа с маркером][синий]

Синяя обёртка пока не способствует созданию иллюзии туннеля. 

#### Шаг 3: Части куба становятся невидимыми

> git checkout example_7
> [демо][96], [дифф][97], [метка][98], [видео][99]

Для создания иллюзии нужно чтобы синяя «накидка» стала невидимой, сохраняя свои возможности блокиратора — она должна стать невидимым блокиратором. Фокус в том чтобы отключить цветовые буфера и производить отрисовку только в буфере глубины. [Используем метод `render()`][101]:

    function render() {
        // Отрисовка реальной сцены
        renderer.render(reality.scene, reality.camera);
 
        // Отключение цветового и альфа- буферов, оставляем включённым только буфер глубины.
        renderer.context.colorMask(false,false,false,false);
 
        // Отрисовка сцены с блокиратором
        renderer.render( occluder.scene, occluder.camera);
 
        // Включение цветового и альфа- буферов.
        renderer.context.colorMask(true,true,true,true);
 
        // Отрисовка компонентов дополненной реальности поверх реальной сцены.
        renderer.render(virtual.scene, virtual.camera);
    }

![Иллюзия][Иллюзия]

Это даёт нам намного более убедительную иллюзию.

### Выбор отверстий

> git checkout example_8
> [демо][102], [дифф][103], [метка][104]

В игре «An AR Game» пользователь может выбрать какой туннель открыть разместив маркер под прицельную сетку. Это ключевой аспект игры, с технической точки зрения его можно назвать *выбором объекта*. Благодаря ThreeJS это довольно просто реализовать. Ключевые классы — `THREE.Projector()` и `THREE.Raycaster()`, однако есть небольшая оговорка: хотя ключевой метод имеет название `Raycaster.intersectObject()`, он принимает `THREE.Mesh` в качестве параметра. Следовательно, мы [добавляем сетку с названием «хитбокс»][106] в `createMarkerObject()`. В нашем случае [это невидимая геометрическая плоскость][107]. Обратите внимание что мы не указываем напрямую расположение этой сетки, оставляя для неё значение по умолчанию — (0,0,0), относительно объекта `markerContainer`. Это располагает её возле входного отверстия туннеля, в плоскости страницы с маркерами, где располагалась бы удалённая нами сторона куба если бы мы её не удалили. 

Теперь у нас есть в наличии хитбокс, который можно протестировать, мы создаём класс с названием `Reticle` *(«прицельная метка» — прим. переводчика)* для определения точки пересечения координат и отслеживания состояния. Уведомления от прицельной метки применяются к представлению дополненной реальности посредством подключения функции обратного вызова при добавлении объекта через `arivew.add()`. Эта функция обратного вызова запускается при выборе объекта, например:

    view.add( object, function(isSelected) {
        onMarkerSelectionChanged(marker.id, isSelected);
    });

Теперь игрок имеет возможность выбрать маркеры дополненной реальности, расположив их по центру экрана. 

## Реорганизация кода

> git checkout example_9
> [демо][108], [дифф][109], [метка][110]

С функционалом дополненной реальности мы по сути закончили. У нас есть возможность распознать маркеры в фреймах вебкамеры и выровнять 3D-объекты согласно им. Также можно определить когда выбран маркер. Мы готовы перейти к второму ключевому компоненту игры «An AR Game»: плоскому двухмерному пространству, из которого пользователь перемещает игровые объекты. Для этого потребуется приличное количество кода и предварительная реорганизация кода может помочь сохранить его изящность. Обратите внимание, что большая часть функционала ДР на данный момент помещена в главном файле application.js. Давайте его оттуда вырежем и поместим в отдельный модуль с названием [realspace.js][111], что сделает файл [application.js][112] намного чище. 

## Панель плоского пространства

> git checkout example_10
> [демо][113], [дифф][114], [метка][115]

В игре «An AR Game» задача игрока состоит в перемещении игровых объектов из двухмерной плоскости в трёхмерное пространство. Модуль реального пространства, реализованный ранее, служит трёхмерным пространством. Наша двухмерная плоскость будет управляться модулем под названием flatspace.js, [создание которого начинается из каркасного шаблона][116], похожего на скелет [application.js][117] и [realspace.js][118].

### Физика

> git checkout example_11
> [демо][119], [дифф][120], [метка][121]

[Физика][122] представления реального пространства досталась нам на халяву от [природы][123]. Однако для панели плоского пространства используется имитация двухмерной физики, что требует межплатформенного ПО для реализации физики. Мы будем использовать JavaScript-[транскомпиляцию][124] известного движка [Box2D][125] под названием [Box2D.js][126]. Версия на JavaScript берёт начало от исходного движка на [C++][127], пропущенного через [систему LLVM][128], и обработанного компилятором [emscripten][129].

Box2D — это довольно сложная программа, однако для неё есть подробные [документация][130] и [описания возможностей][131]. Поэтому в большинстве своём в этой статье я удержусь от повторения того, что итак уже исчерпывающе описано в других источниках. Вместо этого в ней будут описаны распространённые проблемы при использовании Box2D, предложено решение в виде модуля и описана её интеграция в flatspace.js.

Сначала построим [оболочку для сырого движка Box2D.js][132] и назовём её boxworld.js. затем она [интегрируется в плоское пространство][133]. 

Это не приносит никакого зримого визуального эффекта, но фактически теперь мы имитируем вакуум.

### Визуализация

Неплохо было бы иметь возможность видеть что происходит. Box2D предусмотрительно представляет отображение отладки и Box2D.js упрощает его с помощью своего рода [виртуальных методов][134]. Функции будут проводить отрисовку в контекст `canvas`, так что нам нужно создать полотно `canvas` и затем предоставить методы отрисовки для таблицы виртуальных методов.

#### Шаг №1: Создаём метрическую канву

> git checkout example_12
> [демо][135], [дифф][136], [метка][137]

`canvas` служит для преобразования данных мира Box2D. Единицей измерения для `canvas` служат пиксели, в то время как для описания пространства Box2D используются метры. Нам потребуются методы для конвертации одних единиц в другие на основе [коэффициента пикселя к метру][138]. Методы конвертации используют эту константу для преобразования [пикселей в метры][139] и [метров в пиксели][140]. Мы также [выравниваем исходные координаты][141]. Эти методы привязаны к `canvas` и обёрнуты в [модуль boxview.js][142]. Так его проще [встроить в плоское пространство][143]:

Он подвергается обработке при инициализации, затем его `canvas` добавляется в DOM:

    view = boxview.create({
        width:640, 
        height:480,
        pixelsPerMeter:13,
    });
 
    document.getElementById("flatspace").appendChild( view.canvas );

Теперь на странице есть два полотна `canvas` — плоское пространство и реальное пространство. Немного CSS в [application.css][144] располагает их рядом:

    #realspace {
        overflow:hidden;
    }
 
    #flatspace {
        float:left;
    }

#### Шаг 2: Собираем комплект для разработки

> git checkout example_13
> [демо][145], [дифф][146], [метка][147]

Как уже упоминалось, Box2D.js предоставляет привязки для отрисовки отладочного эскиза мира. К ним можно получить доступ через [таблицу виртуальных методов][148] с помощью метода [`customizeVTable()`][149] и впоследствии вызвать с помощью [`b2World.DrawDebugData()`][150]. Мы позаимствуем методы отрисовки из описания [разработчика с псевдонимом kripken][151] и обернём их в в модуль с названием [boxdebugdraw.js][152].

Теперь можно проводить отрисовку, но отрисовывать нам нечего. Сначала придётся ещё немного попотеть!

### Волокита

Мир Box2D населён объектами, которые называются телами. Тело, добавленное в мир Box2D, подчиняется законам физики, но оно должно также подчиняться правилам игры. Для этого мы создаём набор главных структур данных и методов для управления телами. Их применение упрощает создание тела, определение столкновения и разрушение тела. Когда эти структуры добавлены, мы можем начать работу над реализацией логики игры, создавая систему, в которой она будет происходить.

#### Создание тела

> git checkout example_14
> [демо][153], [дифф][154], [метка][155]

Давайте оживим имитацию добавив созидательный момент. Код для построения тела Box2D довольно длинный, он включает в себя описание конструкций, форм и физических параметров. Так что мы будем хранить методы для создания тела в модуле [boxbody.js][156]. Чтобы создать тело, мы передаём [метод boxBody][157] [`boxworld.add()`][158]. [Например:][159]

    function populate() {
        var ball = world.add(
            boxbody.ball,
            {
                x:0,
                y:8,
                radius:10
            }
        );
    }

Это даёт нам шар без оформления в воздухе, на который действует гравитация. Если задуматься, он напоминает [одного кита][160]. 

#### Регистрация

> git checkout example_15
> [демо][161], [дифф][162], [метка][163]

Нам необходима возможность ведения учёта тел, которые населяют плоский мир. Box2D предоставляет доступ к списку тел, но он слишком базовый чтобы удовлетворить наши потребности. Вместо этого мы используем поле `b2Body` под названием `userData`. Мы присвоим ему уникальный номер, который впоследствии будет использоваться как индекс в регистре нашего проекта. Он внедрён в boxregistry.js, и является ключевым аспектом реализации плоского пространства. Он делает возможной привязку к телам декоративных элементов (таких как спрайты), упрощает создание функций обратного вызова для столкновений и облегчает удаление тел из имитации. Подробности реализации здесь описаны не будут, но заинтересованные читатели могут просмотреть репозиторий на предмет [обработки регистра][164] в boxworld.js, и возвращения [методом `add()`][165] [тел с обёрткой и занесённых в регистр][166]. 

#### Столкновение

> git checkout example_16
> [демо][167], [дифф][168], [метка][169]

Определение столкновения в Box2D усложнено тем, что родная функция обратного вызова даёт две фиксированные величины, необработанные и неупорядоченные, и мы получаем уведомление о всех столкновениях, происходящих в мире, тем самым сталкиваясь с необходимостью проведения многочисленных проверок условий. Модуль boxregistry.js подходит для управления избыточными данными. Он позволяет присвоить зарегистрированным объектам [функцию обратного вызова `onContact`][170]. Когда запущен Box2D-обработчик столкновения, [мы отправляем в регистр запрос на соответствующие объекты][171] и проверяем [наличие функции обратного вызова][172]. Если для объекта определена функция обратного вызова, мы знаем что его активность представляет интерес. Чтобы использовать этот алгоритм в flatspace.js, нужно просто [присвоить зарегистрированному объекту функцию обратного вызова при столкновении][173]:

    function populate() {
        var ground = world.add(
            boxbody.edge,
            {
                x:0,
                y:-15,
                width:20,
                height:0,
            }
        );
 
        var ball = world.add(
            boxbody.ball,
            {
                x:0,
                y:8,
                radius:10
            }
        );
 
        ball.onContact = function(object) {
            console.log("Шар вступил в контакт с:", object);
        };
    }

#### Удаление

> git checkout example_17
> [демо][174], [дифф][175], [метка][176]

Удаление тел осложнено тем, что Box2D не разрешает обращения к `b2World.DestroyBody()` из `b2World.Step()`. Это важно, поскольку обычно тело нужно удалить после столкновения, а функция обратного вызова при столкновении встречается во время шага имитации: это парадокс! Одно из решений — ставить тела в очередь на удаление, а затем подвергать эту очередь обработке за пределами шага имитации. `boxregistry` предоставляет решение для этой проблемы посредством установления флага [`isMarkedForDeletion`][177] для каждого объекта. Происходит [перебор набора зарегистрированных объектов и обработчики получают извещение о запросе на удаление][178]. Итерация [происходит после шага имитации][179], так что [функция удаления полностью уничтожает тела][180]. Проницательные читатели возможно догадались, что теперь [перед вызовом функции столкновения мы проверяем флаг `isMarkedForDeletion`][181]. 

Когда речь идёт о flatspace.js, всё происходит прозрачно, так что от нас требуется только [установить флаг удаления для зарегистрированного объекта][182]:

    ball.onContact = function(object) {
        console.log("Шар вступил в контакт с:", object);
        ball.isMarkedForDeletion = true;
    };

Теперь тело удаляется при контакте с поверхностью.

#### Различение

> git checkout example_18
> [демо][183], [дифф][184], [метка][185]

Когда определено столкновение, игре нужно знать с чем столкнулся объект. Для этого мы добавим [для зарегистрированных объектов метод `is()`][186], который используется для сравнения объектов. Теперь добавим в игру условие для удаления:

    ball.onContact = function(object) {
        console.log("Шар вступил в контакт с:", object);
        if( object.is( ground ) ) {
            ball.isMarkedForDeletion = true;
        }
    };

### Двухмерный туннель

> git checkout example_19
> [демо][187], [дифф][188], [метка][189]

Мы уже обсудили туннели в реальном пространстве, теперь нужно реализовать их копии в плоском пространстве. Туннель в плоском пространстве представляет собой тело, состоящее из датчика Box2D. Шар должен пройти *над* закрытым туннелем, но *через* открытый туннель. Теперь представьте крайний случай когда шар проходит над закрытым туннелем, который затем открывается. Проблема состоит в том, что обработчик `onBeginContact` ведёт себя согласно своему названию, понимая что контакт с туннелем был определён при закрытом состоянии, после чего туннель был открыт. Следовательно траектория шара не искривляется и мы получаем ошибку. Решить это можно используя совокупность датчиков. При использовании совокупности датчиков мы получаем ряд событий `BeginContact` по мере движения шара над туннелем. Так мы можем быть уверены что открытие туннеля, когда шар движется над ним, приведет к изменению траектории шара. Генератор совокупности датчиков называется [`hole` и реализован в boxbody.js][190]. Сгенерированная совокупность датчиков выглядит так:

![Сгенерированная совокупность датчиков][пример]

## Перевалочный пункт

На данный момент мы подготовили к использованию модули на основе JSARToolkit и Box2D.js. Мы использовали их чтобы создать туннель в реальном пространстве и плоском пространстве. Целью игры является перемещение игровых объектов из плоского пространства в реальное пространство, потому нам нужно обеспечить обмен данными между этими туннелями. Мы подойдём к этому так:

1. `git checkout example_20`

[демо][191], [дифф][192], [метка][193]

Уведомляем приложение об изменении состояния туннеля в реальном пространстве.

2. `git checkout example_21`

[демо][194], [дифф][195], [метка][196]

Синхронизируем состояние туннеля в плоском пространстве с состоянием туннеля в реальном пространстве.

3. `git checkout example_22`

[демо][197], [дифф][198], [метка][199]

Уведомляем приложение когда шар проходит через открытый туннель в плоском пространстве.

4. `git checkout example_23`

[демо][200], [дифф][201], [метка][202]

Добавляем шар в реальном пространстве когда приложение получает уведомление о прохождении.

## Заключение

В этой статье показана техническая основа игры «An AR Game». Мы создали две панели различающихся реальностей и соединили их туннелем. Игрок теперь может развлекаться, перемещая шар из плоского пространства в реальное пространство. С технической точки зрения это интересно, но в общем не особо весело. 

Ещё много предстоит сделать чтобы это приложение стало игрой, но это уже выходит за пределы темы этой статьи. Нерешёнными остаются такие задачи как:

* Спрайты и анимация.
* Введение нескольких шаров и туннелей.
* Предоставление возможности интерактивной проектировки уровней.

Спасибо что прочитали статью! Надеюсь что вдохновили вас на дальнейшее углубление в эту тему!

[1]: https://developer.mozilla.org/fr/demos/detail/an-ar-game
[2]: https://developer.mozilla.org/en/demos/devderby/2013/may
[3]: https://developer.mozilla.org/en/demos/devderby
[4]: http://en.wikipedia.org/wiki/Augmented_reality
[5]: http://abrie.github.io/devderby-may-2013/
[6]: http://www.youtube.com/watch?v=Pa_EwQ0DoWk
[7]: http://dev.w3.org/2011/webrtc/editor/getusermedia.html
[8]: https://github.com/kig/JSARToolKit
[9]: https://github.com/mrdoob/three.js/
[10]: https://github.com/kripken/box2d.js
[11]: https://github.com/abrie/devderby-may-2013-technical
[12]: https://github.com/abrie/devderby-may-2013-technical/tags
[13]: http://abrie.github.io/devderby-may-2013-technical/
[14]: #realspace
[15]: #flatspace
[16]: #conduit
[17]: http://abrie.github.io/devderby-may-2013-technical/example_0/application.html
[18]: https://github.com/abrie/devderby-may-2013-technical/commit/bef8bf5c6505e30a3fc9ad0f2f4564df060c4296
[19]: https://github.com/abrie/devderby-may-2013-technical/tree/example_0
[20]: http://requirejs.org/
[21]: https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame
[22]: http://abrie.github.io/devderby-may-2013-technical/example_1/application.html
[23]: https://github.com/abrie/devderby-may-2013-technical/commit/4d7f2faa18b794be4bd0a10d4fa0c6dfa306e519
[24]: https://github.com/abrie/devderby-may-2013-technical/tree/example_1
[25]: http://en.wikipedia.org/wiki/HTML5
[26]: http://en.wikipedia.org/wiki/Webrtc
[27]: http://en.wikipedia.org/wiki/Webcam
[28]: https://www.mozilla.org/en-US/firefox/new/?utm_source=firefox-com&utm_medium=referral
[29]: https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getUserMedia
[30]: https://developer.mozilla.org/en-US/
[31]: http://requirejs.org/docs/api.html#define
[32]: https://github.com/abrie/devderby-may-2013-technical/blob/master/webcam.js
[33]: https://github.com/abrie/devderby-may-2013-technical/commit/4d7f2faa18b794be4bd0a10d4fa0c6dfa306e519/#L0R32
[34]: https://github.com/abrie/devderby-may-2013-technical/commit/4d7f2faa18b794be4bd0a10d4fa0c6dfa306e519/#L0R25
[35]: http://abrie.github.io/devderby-may-2013-technical/example_2/application.html
[36]: https://github.com/abrie/devderby-may-2013-technical/commit/388378463230b28c333b4954154f087919d7a3c2
[37]: https://github.com/abrie/devderby-may-2013-technical/tree/example_2
[38]: http://en.wikipedia.org/wiki/Fiduciary_marker
[39]: https://github.com/kig/JSARToolKit/tree/master/demos/markers
[40]: http://www.hitl.washington.edu/artoolkit/
[41]: http://en.wikipedia.org/wiki/C%2B%2B
[42]: http://en.wikipedia.org/wiki/University_of_Washington
[43]: http://www.hitl.washington.edu/home/
[44]: http://en.wikipedia.org/wiki/Seattle
[45]: http://nyatla.jp/nyartoolkit/wp/?page_id=198
[46]: http://www.libspark.org/wiki/saqoosha/FLARToolKit/en
[47]: https://github.com/kig/JSARToolKit
[48]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/ardetector.js#L10
[49]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/ardetector.js#L24
[50]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/ardetector.js#L65
[51]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L34
[52]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L47
[53]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L34
[54]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L47
[55]: http://abrie.github.io/devderby-may-2013-technical/example_3/application.html
[56]: https://github.com/abrie/devderby-may-2013-technical/commit/c9de6aaf6805c760bbab6671126c323ac4227dad
[57]: https://github.com/abrie/devderby-may-2013-technical/tree/example_3
[58]: https://github.com/abrie/devderby-may-2013-technical/blob/example_2/application.js#L19
[59]: https://developer.mozilla.org/en-US/docs/Web/WebGL?redirectlocale=en-US&redirectslug=WebGL
[60]: https://github.com/abrie/devderby-may-2013-technical/blob/example_3/arview.js#L11
[61]: https://github.com/abrie/devderby-may-2013-technical/blob/example_3/arview.js#L14
[62]: https://github.com/abrie/devderby-may-2013-technical/blob/example_3/application.js#L31
[63]: http://en.wikipedia.org/wiki/Cache_%28computing%29
[64]: #example_2
[65]: http://abrie.github.io/devderby-may-2013-technical/example_4/application.html
[66]: https://github.com/abrie/devderby-may-2013-technical/commit/e16eb6c510d3f0e38b66057befa51406b516e38c
[67]: https://github.com/abrie/devderby-may-2013-technical/tree/example_4
[68]: http://www.youtube.com/watch?v=g4n9lebq_Kg&feature=youtu.be
[69]: http://en.wikipedia.org/wiki/Transformation_matrix
[70]: http://en.wikipedia.org/wiki/Camera_matrix
[71]: https://github.com/abrie/devderby-may-2013-technical/blob/master/ardetector.js
[72]: https://developer.mozilla.org/en-US/docs/Web/API/Float32Array?redirectlocale=en-US&redirectslug=Web%2FJavaScript%2FTyped_arrays%2FFloat32Array
[73]: http://en.wikipedia.org/wiki/Monkey_patch
[74]: http://en.wikipedia.org/wiki/Cache_%28computing%29
[75]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/arobject.js#L21
[76]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/arobject.js#L16
[77]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/arobject.js#L19
[78]: https://github.com/abrie/devderby-may-2013-technical/blob/example_4/application.js#L57
[79]: http://abrie.github.io/devderby-may-2013-technical/example_5/application.html
[80]: https://github.com/abrie/devderby-may-2013-technical/commit/1c28aa84b7559cdd46f04d31ef94abb7b7136854
[81]: https://github.com/abrie/devderby-may-2013-technical/tree/example_5
[82]: http://www.youtube.com/watch?v=50nYnIBJtTg&feature=youtu.be
[83]: https://github.com/abrie/devderby-may-2013-technical/blob/example_5/arobject.js#L35
[84]: https://github.com/abrie/devderby-may-2013-technical/blob/example_5/arobject.js#L29
[85]: https://github.com/abrie/devderby-may-2013-technical/blob/example_5/arobject.js#L38
[86]: http://abrie.github.io/devderby-may-2013-technical/example_6/application.html
[87]: https://github.com/abrie/devderby-may-2013-technical/commit/0e4f2d5b9058425cbf61befabb510df20d5563ac
[88]: https://github.com/abrie/devderby-may-2013-technical/tree/example_6
[89]: http://www.youtube.com/watch?v=BtAxElxQiFk&feature=youtu.be
[90]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arobject.js#L44
[91]: #step3
[92]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arobject.js#L46
[93]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arview.js#L78
[94]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arview.js#L75
[95]: https://github.com/abrie/devderby-may-2013-technical/blob/example_6/arview.js#L85
[96]: http://abrie.github.io/devderby-may-2013-technical/example_7/application.html
[97]: https://github.com/abrie/devderby-may-2013-technical/commit/81b4a4ae2c44a910b319eff43edd7b1f8ea1651c
[98]: https://github.com/abrie/devderby-may-2013-technical/tree/example_7
[99]: http://www.youtube.com/watch?v=GM5eu3NBMZY&feature=youtu.be
[100]: https://github.com/abrie/devderby-may-2013-technical/blob/example_7/arview.js#L90
[101]: https://github.com/abrie/devderby-may-2013-technical/blob/example_7/arview.js#L85
[102]: http://abrie.github.io/devderby-may-2013-technical/example_8/application.html
[103]: https://github.com/abrie/devderby-may-2013-technical/commit/3f236ed4f79704be9733cba55efd4f4c47a35ef5
[104]: https://github.com/abrie/devderby-may-2013-technical/tree/example_8
[105]: http://en.wiktionary.org/wiki/caveat
[106]: https://github.com/abrie/devderby-may-2013-technical/blob/example_8/arobject.js#L78
[107]: https://github.com/abrie/devderby-may-2013-technical/blob/example_8/arobject.js#L43
[108]: http://abrie.github.io/devderby-may-2013-technical/example_9/application.html
[109]: https://github.com/abrie/devderby-may-2013-technical/commit/005f87d6c40322309ad9a68d4b2627cc6599684d
[110]: https://github.com/abrie/devderby-may-2013-technical/tree/example_9
[111]: https://github.com/abrie/devderby-may-2013-technical/blob/example_9/realspace.js
[112]: https://github.com/abrie/devderby-may-2013-technical/blob/example_9/application.js
[113]: http://abrie.github.io/devderby-may-2013-technical/example_10/application.html
[114]: https://github.com/abrie/devderby-may-2013-technical/commit/1ae5a00a63d0a6def6aeeab1f6d6fa7552f9d488
[115]: https://github.com/abrie/devderby-may-2013-technical/tree/example_10
[116]: https://github.com/abrie/devderby-may-2013-technical/blob/example_10/flatspace.js
[117]: https://github.com/abrie/devderby-may-2013-technical/blob/example_0/application.js
[118]: https://github.com/abrie/devderby-may-2013-technical/blob/example_9/realspace.js
[119]: http://abrie.github.io/devderby-may-2013-technical/example_11/application.html
[120]: https://github.com/abrie/devderby-may-2013-technical/commit/23e97233b1da08b4aebedd96917e406613286c1a
[121]: https://github.com/abrie/devderby-may-2013-technical/tree/example_11
[122]: http://en.wikipedia.org/wiki/Motion_%28physics%29
[123]: http://en.wikipedia.org/wiki/Nature
[124]: http://en.wikipedia.org/wiki/Source-to-source_compiler
[125]: http://en.wikipedia.org/wiki/Box2d
[126]: https://github.com/kripken/box2d.js/
[127]: https://code.google.com/p/box2d/
[128]: http://en.wikipedia.org/wiki/LLVM
[129]: https://github.com/kripken/emscripten
[130]: http://box2d.org/manual.pdf
[131]: http://box2d.org/manual.pdf
[132]: https://github.com/abrie/devderby-may-2013-technical/blob/example_11/boxworld.js
[133]: https://github.com/abrie/devderby-may-2013-technical/commit/23e97233b1da08b4aebedd96917e406613286c1a#diff-19f884bd80981aedf202452cae4fc0f0
[134]: http://en.wikipedia.org/wiki/Virtual_function
[135]: http://abrie.github.io/devderby-may-2013-technical/example_12/application.html
[136]: https://github.com/abrie/devderby-may-2013-technical/commit/dfa4fee9ccb3a40d17b7678adfdeb0d87a63420b
[137]: https://github.com/abrie/devderby-may-2013-technical/tree/example_12
[138]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L9
[139]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L24
[140]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L31
[141]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js#L12
[142]: https://github.com/abrie/devderby-may-2013-technical/blob/example_12/boxview.js
[143]: https://github.com/abrie/devderby-may-2013-technical/commit/dfa4fee9ccb3a40d17b7678adfdeb0d87a63420b#diff-19f884bd80981aedf202452cae4fc0f0
[144]: https://github.com/abrie/devderby-may-2013-technical/blob/7d2c4de27aa3ed5b04ab1b02c0e79643a51e17f2/application.css
[145]: http://abrie.github.io/devderby-may-2013-technical/example_13/application.html
[146]: https://github.com/abrie/devderby-may-2013-technical/commit/806d65ceca9707463a1cdfebc9d8feef433d85eb
[147]: https://github.com/abrie/devderby-may-2013-technical/tree/example_13
[148]: http://en.wikipedia.org/wiki/Virtual_method_table
[149]: https://github.com/kripken/box2d.js/#using-debug-draw
[150]: https://github.com/abrie/devderby-may-2013-technical/blob/example_13/boxdebugdraw.js#L181
[151]: https://github.com/kripken/box2d.js/#using-debug-draw
[152]: https://github.com/abrie/devderby-may-2013-technical/blob/example_13/boxdebugdraw.js
[153]: http://abrie.github.io/devderby-may-2013-technical/example_14/application.html
[154]: https://github.com/abrie/devderby-may-2013-technical/commit/b7117c1914941514855e01ee1a9573b853f4811a
[155]: https://github.com/abrie/devderby-may-2013-technical/tree/example_14
[156]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/boxbody.js
[157]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/boxbody.js#L5
[158]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/boxworld.js#L13
[159]: https://github.com/abrie/devderby-may-2013-technical/blob/example_14/flatspace.js#L33
[160]: http://en.wikipedia.org/wiki/List_of_minor_The_Hitchhiker%27s_Guide_to_the_Galaxy_characters#Whale
[161]: http://abrie.github.io/devderby-may-2013-technical/example_15/application.html
[162]: https://github.com/abrie/devderby-may-2013-technical/commit/04a86c1b28b642d876dd7e80947f361718c120d6
[163]: https://github.com/abrie/devderby-may-2013-technical/tree/example_15
[164]: https://github.com/abrie/devderby-may-2013-technical/blob/example_15/boxworld.js#L8
[165]: https://github.com/abrie/devderby-may-2013-technical/blob/example_15/boxworld.js#L14
[166]: https://github.com/abrie/devderby-may-2013-technical/blob/example_15/boxworld.js#L16
[167]: http://abrie.github.io/devderby-may-2013-technical/example_16/application.html
[168]: https://github.com/abrie/devderby-may-2013-technical/commit/d6a6657060d040bec2a002deac34d03e81122d25
[169]: https://github.com/abrie/devderby-may-2013-technical/tree/example_16
[170]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/boxregistry.js#L20
[171]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/boxworld.js#L38
[172]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/boxworld.js#L41
[173]: https://github.com/abrie/devderby-may-2013-technical/blob/example_16/flatspace.js#L52
[174]: http://abrie.github.io/devderby-may-2013-technical/example_17/application.html
[175]: https://github.com/abrie/devderby-may-2013-technical/commit/9d9c2b91c7c7f55610d0b8459eccc76c4381c554
[176]: https://github.com/abrie/devderby-may-2013-technical/tree/example_17
[177]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxregistry.js#L22
[178]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxregistry.js#L50
[179]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxworld.js#L26
[180]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxworld.js#L18
[181]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/boxworld.js#L48
[182]: https://github.com/abrie/devderby-may-2013-technical/blob/example_17/flatspace.js#L54
[183]: http://abrie.github.io/devderby-may-2013-technical/example_18/application.html
[184]: https://github.com/abrie/devderby-may-2013-technical/commit/682aa2b215e6d918393d03dd103f3338c59a2be0
[185]: https://github.com/abrie/devderby-may-2013-technical/tree/example_18
[186]: https://github.com/abrie/devderby-may-2013-technical/blob/example_18/boxregistry.js#L23
[187]: http://abrie.github.io/devderby-may-2013-technical/example_19/application.html
[188]: https://github.com/abrie/devderby-may-2013-technical/commit/736662188f65cbdb6aae7572ffcc46d1ced38253
[189]: https://github.com/abrie/devderby-may-2013-technical/tree/example_19
[190]: https://github.com/abrie/devderby-may-2013-technical/blob/example_19/boxbody.js#L42
[191]: http://abrie.github.io/devderby-may-2013-technical/example_20/application.html
[192]: https://github.com/abrie/devderby-may-2013-technical/commit/ada13bcf70b633a06afbad065d2cdea6b86baeb2
[193]: https://github.com/abrie/devderby-may-2013-technical/tree/example_20
[194]: http://abrie.github.io/devderby-may-2013-technical/example_21/application.html
[195]: https://github.com/abrie/devderby-may-2013-technical/commit/b93aab3db72cdcd004d1048c9a7e8b097ced547f
[196]: https://github.com/abrie/devderby-may-2013-technical/tree/example_21
[197]: http://abrie.github.io/devderby-may-2013-technical/example_22/application.html
[198]: https://github.com/abrie/devderby-may-2013-technical/commit/7d1c2a2ce676f19a1970ce254eeecbeced299a34
[199]: https://github.com/abrie/devderby-may-2013-technical/tree/example_22
[200]: http://abrie.github.io/devderby-may-2013-technical/example_23/application.html
[201]: https://github.com/abrie/devderby-may-2013-technical/commit/05b6bf16fa2da753ddfd9a777a5523e2272df693
[202]: https://github.com/abrie/devderby-may-2013-technical/tree/example_23

[маркеры]: img/AR-Game-16_and_32.png
[Страница с маркерами]: img/AR-Game-example_3.png
[кубики]: img/AR-Game-example_4.png
[незаконченный эффект]: img/AR-Game-example_5.png
[синий]: img/AR-Game-example_6.png
[Иллюзия]: img/AR-Game-example_7.png
[пример]: img/sensor-cluster.png